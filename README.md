DNS-Resolver-with-Poco-C-libraries
This project implements a command-line DNS resolver in C++ using the Poco Net library. It takes a domain name as input and returns its corresponding IP address. The resolver features a simple caching mechanism to improve performance for repeated queries and includes error handling for invalid domains. The project demonstrates practical use of networking libraries, CMake build system, and modern C++ practices.
This project involves the design and implementation of a DNS Resolver in C++ using the Poco C++ Libraries. The resolver is capable of efficiently converting domain names into IP addresses. To enhance performance and accuracy, the system also supports caching of resolved IPs and recursive resolution of domain names. The development was structured over five days, each with clearly defined goals and deliverables to ensure progressive enhancement and modular implementation.

Day 1: Project Setup and DNS Basics
The first day focused on laying the foundation for the DNS Resolver project. The development environment was configured with Visual Studio Code and the MSYS2 MinGW UCRT64 toolchain. The Poco C++ libraries were installed and linked to support network programming features, particularly DNS query capabilities. A basic project structure was created, including folders for source files (src), headers (include), and build configuration (CMakeLists.txt). Alongside the setup, an in-depth study of DNS fundamentals was conducted, covering concepts like domain names, IP addressing, DNS hierarchy, and the resolution process. The architectural blueprint for the resolver was drafted, outlining separate components for query handling, caching, recursive resolution, and main execution flow.

Day 2: Implementing DNS Query Handling
On the second day, the implementation of core DNS query handling was carried out using the Poco::Net module. A function was developed to send DNS queries and retrieve corresponding IP addresses. Using Poco::Net::DNS::hostByName(), the resolver was able to perform synchronous DNS lookups. Additionally, logic was added to parse and display the returned IP addresses to the user. These implementations were tested with several sample domains such as example.com, google.com, and others to verify correctness. This phase ensured that the resolver could interact with external DNS infrastructure and extract meaningful data for subsequent operations.

Day 3: Caching Resolved Addresses
To improve efficiency and minimize redundant network calls, a caching layer was introduced on the third day. The cache was implemented using standard C++ containers such as std::unordered_map, mapping domain names to resolved IP addresses and timestamps. The logic was designed to first check the cache before initiating any new DNS queries. This approach ensured that repeated queries to the same domain would return results instantly from memory, reducing DNS traffic and latency. The caching mechanism was successfully tested by running multiple repeated queries, validating that only the first resulted in an actual DNS request while others were served from the cache.

Day 4: Recursive Resolution
The fourth day focused on enabling recursive resolution capabilities, allowing the resolver to handle multi-level domain queries that require interaction with several authoritative DNS servers. A recursive resolver class was implemented that mimicked the behavior of a recursive DNS server, resolving a domain name by following a hierarchy of name servers from the root to the authoritative server. This was done by simulating recursive lookup chains using the Poco DNS tools and enhancing the system with robust error handling. Mechanisms were put in place to handle timeouts, invalid domain formats, and unreachable DNS servers gracefully. Extensive testing ensured that complex domains like sub.domain.example.com were resolved effectively.

Day 5: Testing, Documentation, and Optimization
The final day involved a complete evaluation of the DNS resolver’s performance and functionality. Test cases were written to simulate both normal and edge-case scenarios, including empty inputs, repeated queries (to test caching), and deep recursive lookups. The codebase was reviewed and optimized for performance, focusing on reducing memory usage and improving response times. The resolver’s logic was modularized and commented clearly for maintainability. Documentation was prepared, covering setup instructions, architecture overview, usage examples, and future improvement suggestions. Additionally, a summary presentation highlighting major design decisions, challenges like parsing DNS responses and recursive querying logic, and the strategies adopted for optimization was created.

